# 基本定义
树 ，n(n>=0)个结点的有限集合，构成一个根结点形成前后元素的前驱后继的结构

度（degree）

结点拥有的子树数称为结点的度，如这个结点有多少个结点

如 D 有三个子结点连接起来G，H，I，所以它的度为3

结点子树叫做孩子 child

同一个双亲的孩子叫兄弟 sibling

祖先，如结点 H，它的祖先有 D、B、A

结点的层次 level 从根开始，根为第一层，根的孩子为第二层，数中结点的最大层次称为数的深度Depth

森林，是多个树组成的集合

公式


# 二叉树 binary tree


定义，一个结点最多2个度，也就是一个结点最多只有两个孩子，缺左缺右都可以

## 特点
每个结点最多有两个子树，也就是一个结点最多只有两个孩子


## 满二叉树

左右叶子都存在

## 完全二叉树

每个结点都有编号，按照从左至右进行排列，编号循序需要根据结点数对齐，不能缺左子树

1、叶子节点只能出现最两层

2、最下层的叶子一定集中在左部连续位置

3、倒数二层，若有叶子节点，一定都在右部连续位置

4、如果节点度为1，则该节点只有左孩子，即不存在只有右子树的情况

5、同样结点数的二叉树，完全二叉树的深度最小

## 二叉树的性质

### 性质1，在二叉树的第i层至多有2^(i-1)个节点 i>=1

第一层，2^(1-1) = 2^0 = 1
第二层，2^(2-1) = 2
....

### 性质2，深度为k的二叉树至多有2^k - 1 个结点 k>=1
只有一层 1 = 2^0 - 1 个结点
有两层，1 + 2 = 3 = 2^2 - 1 个结点
...
通过数学归纳法真名，二叉树至少有2^k - 1 个结点

### 性质3，任何一课二叉树 T，终端结点为n0，度为2的节点数为n2，则 n0 = n2 + 1

推导，二叉树的分支线 = n - 1 = n1 + 2n2，而n = n0 + n1 + n2 推导出 n0 + n1 + n2 - 1 = n1 + 2n2  => n0 = n2 + 1

### 性质4，具有n个结点的完全二叉树的深度为|log2n| + 1

### 性质5 如果对一课有n个结点的完全二叉树 深度为 |log2n| +1 的节点按层序编号，从第1层到第|log2n| + 1 层 ，每层从左到右，任一结点 i 有

1、如果 i = 1 ，则节点i是二叉树的根，无双亲，如果i>1,则其双亲是结点 i/2

2、如果 2i > n ，则结点 i 无左孩子，否则左孩子是结点2i

3、如果 2i + 1 > n ， 则结点 i 无右孩子，否则其右孩子是结点 2i + 1





# 抽象数据类型
```
ADT Tree

Data

Operation
    InitTree(*T) 构造空树
    DestroyTree(*T) 销毁树
    CreateTree(*T, definition) 按 definition 中给出树的定义来构造树
    ClearTree(*T) 清空树
    TreeEmpty(T) 树是否为空
    TreeDepth(T) 树的深度
    Root(T) 返回T的根节点
    Value(T,cur_e) cur_e 是树T中一个节点，返回此节点的值
    Assign(T, cur_e, value) 给树T的节点cur_e复制为value
    Parent(T, cur_e) 若cur_e是树T的非跟节点，则返回它的双亲，否则返回空
    LeftChild(T, cur_e) 若cur_e是树T的非叶节点，则返回它的左孩子
    RightSibling(T, cur_e) 返回右兄弟
    InsertChild(*T, *p,i,c) p指向树T的某个节点，i为所指结点p的度加上1，若非空树c与T不相交，操作结果为插入c为树T中p指节点的第i课子树
    DeleteChild(*T,*p,i) 其中p指向插入c为树T中p指节点的第i课子树，操作结果删除T中p所指节点的第i可子树

```

# 存储结构

## 双亲表示法

节点结构 -> [data|parent] parent 指向双亲的位置，根为 -1，如 下图， A为根节点，B，C 为A 的子节点，parent 指向A的下标0

|下标|data|parent|
----------------
0   | A   |  -1  |
------------------
1   | B   |  0   |
------------------
2   | C   |  0   |
------------------

时间复杂度为O(1), 根据parent指针就能定位到，但需要遍历整个结构才行,通过增加长子域，就容易得到节点的孩子

|下标|data|parent| firstchild|
-----------------------------
0   | A   |  -1  |    -1    |
-----------------------------
1   | B   |  0   |     3    |
----------------------------|
2   | C   |  0   |     4    |
-----------------------------
3   | D   |  1   |     -1   | 
-----------------------------
4   | E   |  2   |     -1   | 
-----------------------------

如此类推，我们可以增加 rightslib 来寻找它的右兄弟

## 孩子表示法
[data|child1|child2|....|childd]

child 用来指向它的孩子

但这种需要预留多少child位置呢？

在这里加多个 degree 来记录这里有多少个孩子

[data|degree|child1|child2|....|childd]

[A|2|child1|child2]

child1 指向 B，child2 指向 C

degree 表示节点的度

这种方法节省空间，但要维护节点的度数值，如果需要增加，在运算上带来时间上的损耗

另外一种表示方式为【单链表存储结构 + 顺序存储结构】

【简言而之】元素存储在顺序结构[data|firstchild]，firstchild 指向 [child下标|next] , next 指向下一个元素，通过链表减少[data|child1|child2|....|childd]结构计算压力

## 孩子兄弟表示法

同样道理，通过 添加 rightslib 不断指向右兄弟
[data|firstchild|rightslib]

# 存储结构

### 顺序存储结构

完全二叉树，按层次从左至右插入数据
0|1|2|3|4|5|6|7|8|9|
A|B|C|D|E|F|G|H|I|J|

结点缺失用^表示

0|1|2|3|4|5|6|7|8|9|
A|B|C|^|E|^|G|^|^|J|

缺点
当一个深度为k的右斜树，它只有k个节点，却需要分配 2^k -1 个存储单元空间，浪费空间


### 链表结构

二叉树每个结点最多有两个孩子，所以它涉及一个数据域和两个指针域
|lchild|data|rchild|
lchild 与 rchild 分别存放左右孩子的指针




# 遍历二叉树

有四种遍历方式

1、前缀遍历，先输出根结点，在访问左，最后访问右子树

2、中缀遍历，先输出左子树，在访问根，最后才输出右子树

3、后缀遍历，先输出右子树，在访问左子树，最后才输出根结点

4、层序遍历，每层从左至右输出

中，后缀，需要访问最后一层才不断输出对应的元素，因为子树还有下一层，不断遍历


# 线索二叉树

通过链表二叉树的左右结点，指向前驱和后继，作用为，二叉链表，每个节点指向其左右孩子节点的地址，而不知道某个结点的前驱是谁，后继是谁，要想知道，必须遍历一次，为了节省时间，空闲的节点记录对应的前驱与后继

作用编译遍历

结构为

|lchild|ltag|data|rtag|rchild|

ltag为0时指向该结点的左孩子，为1时指向该结点的前驱

rtag为0时指向该结点的右孩子，为1时指向该结点的后继


加多一个头节点，作用为便于找到最左的元素和最右的元素


适用范围

二叉树需经常遍历或查找结点是需要某种遍历序列中的前驱和后继


# 树、森林二叉树的转换

关键步骤

1、加线，兄弟结点之间加一条连线

2、去线，在树中每个结点，保留它第一个孩子结点的连线，删除它与其它孩子结点之间的连线

3、层次调整，以树的根结点为轴心，将整颗树顺时针转一定角度

# 哈夫曼树应用

场景

判断成绩的不及格，合格，中等，良好，优秀,常规是使用if-else进行判断，当分类多的时候就会出现效率问题

解决方式

根据分数占比的比例，作为权重优先，构建二叉树，频次最高放树的根


定义与原理

1、从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度，如 根节点到D点，需要经过4个连线长度为4

2、数的路径长度就是从树根到每一结点的路径长度之和

3、带权路径长度WPL最小的二叉树称为赫夫曼树，也就是根到每个结点 乘上 链接这个结点的数值

构建最优的赫夫曼树

1、先把有权值的叶子节点按照从小到大的顺序排列成一个有序序列，即A5，E10，B15，D30，C40

2、取头两个最小权值的节点作为一个新节点N1的两个子结点，较小是左孩子，A为N1的左孩子，E为N1的右孩子, 新节点的全职为两个叶子全职的和 5+10 = 15

3、将N1替换A与E，插入有序序列中，保持从小到大排列，即：N1 15，B15 ， D30， C40

4、重复步骤2，将N1与B作为一个新节点N2的两个子结点，N2的权值=15+15=30

5、将N2替换N1与B，插入有序序列中，保持从小到大排列，即：N230,D30,C40

6、重复步骤2，以此类推


### 赫夫曼编码

目的是解决通信的数据远距离最优化问题，如BADCADFEED，文本里只有六个字母ABCDEF，可以使用二进制数据表是

| A | B | C | D | E | F |
|000|001|010|011|100|101|

编码后BADCADFEED=>001 000 011 010 000 011 101 100 100 011

根据 哈夫曼树的构造，把A 27，B 8，C 15，D 15，E 30，F 5 组合成一个哈夫曼树，让后把连线变为 左为0 右为1

对应的编码为
| A  | B  | C  |  D |  E |  F |
|01  |1001| 101| 00 | 11 |1000|

编码后BADCADFEED=>1001 01 00 101 01 00 1000 11 11 00

原来vs新编码 30个字符 vs 25个字符，节省17%传输成本

问题，得到的二进制编码，如果解码, 因为 长短不等很容易混淆

解决这个方法，使用前缀编码，必须是任一字符的编码都不是另一个字符的编码的前缀

如 1001 01 00 101 01 00 1000 11 11 00





# 总结

树的结构，能够通过层次，左右子树的方式，进行元素的分类，适应多个

