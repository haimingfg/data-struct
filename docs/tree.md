# 基本定义
树 ，n(n>=0)个结点的有限集合，构成一个根结点形成前后元素的前驱后继的结构

度（degree）

结点拥有的子树数称为结点的度，如这个结点有多少个结点

如 D 有三个子结点连接起来G，H，I，所以它的度为3

结点子树叫做孩子 child

同一个双亲的孩子叫兄弟 sibling

祖先，如结点 H，它的祖先有 D、B、A

结点的层次 level 从根开始，根为第一层，根的孩子为第二层，数中结点的最大层次称为数的深度Depth

森林，是多个树组成的集合

公式


# 二叉树 binary tree


定义，一个结点最多2个度，也就是一个结点最多只有两个孩子，缺左缺右都可以

## 特点
每个结点最多有两个子树，也就是一个结点最多只有两个孩子


## 满二叉树

左右叶子都存在

## 完全二叉树

每个结点都有编号，按照从左至右进行排列，编号循序需要根据结点数对齐，不能缺左子树

1、叶子节点只能出现最两层

2、最下层的叶子一定集中在左部连续位置

3、倒数二层，若有叶子节点，一定都在右部连续位置

4、如果节点度为1，则该节点只有左孩子，即不存在只有右子树的情况

5、同样结点数的二叉树，完全二叉树的深度最小

## 二叉树的性质

### 性质1，在二叉树的第i层至多有2^(i-1)个节点 i>=1

第一层，2^(1-1) = 2^0 = 1
第二层，2^(2-1) = 2
....

### 性质2，深度为k的二叉树至多有2^k - 1 个结点 k>=1
只有一层 1 = 2^0 - 1 个结点
有两层，1 + 2 = 3 = 2^2 - 1 个结点
...
通过数学归纳法真名，二叉树至少有2^k - 1 个结点

### 性质3，任何一课二叉树 T，终端结点为n0，度为2的节点数为n2，则 n0 = n2 + 1

推导，二叉树的分支线 = n - 1 = n1 + 2n2，而n = n0 + n1 + n2 推导出 n0 + n1 + n2 - 1 = n1 + 2n2  => n0 = n2 + 1

### 性质4，具有n个结点的完全二叉树的深度为|log2n| + 1

### 性质5 如果对一课有n个结点的完全二叉树 深度为 |log2n| +1 的节点按层序编号，从第1层到第|log2n| + 1 层 ，每层从左到右，任一结点 i 有

1、如果 i = 1 ，则节点i是二叉树的根，无双亲，如果i>1,则其双亲是结点 i/2

2、如果 2i > n ，则结点 i 无左孩子，否则左孩子是结点2i

3、如果 2i + 1 > n ， 则结点 i 无右孩子，否则其右孩子是结点 2i + 1


# 存储结构

### 顺序存储结构



# 抽象数据类型
```
ADT Tree

Data

Operation
    InitTree(*T) 构造空树
    DestroyTree(*T) 销毁树
    CreateTree(*T, definition) 按 definition 中给出树的定义来构造树
    ClearTree(*T) 清空树
    TreeEmpty(T) 树是否为空
    TreeDepth(T) 树的深度
    Root(T) 返回T的根节点
    Value(T,cur_e) cur_e 是树T中一个节点，返回此节点的值
    Assign(T, cur_e, value) 给树T的节点cur_e复制为value
    Parent(T, cur_e) 若cur_e是树T的非跟节点，则返回它的双亲，否则返回空
    LeftChild(T, cur_e) 若cur_e是树T的非叶节点，则返回它的左孩子
    RightSibling(T, cur_e) 返回右兄弟
    InsertChild(*T, *p,i,c) p指向树T的某个节点，i为所指结点p的度加上1，若非空树c与T不相交，操作结果为插入c为树T中p指节点的第i课子树
    DeleteChild(*T,*p,i) 其中p指向插入c为树T中p指节点的第i课子树，操作结果删除T中p所指节点的第i可子树

```

# 存储结构

## 双亲表示法

节点结构 -> [data|parent] parent 指向双亲的位置，根为 -1，如 下图， A为根节点，B，C 为A 的子节点，parent 指向A的下标0

|下标|data|parent|
----------------
0   | A   |  -1  |
------------------
1   | B   |  0   |
------------------
2   | C   |  0   |
------------------

时间复杂度为O(1), 根据parent指针就能定位到，但需要遍历整个结构才行,通过增加长子域，就容易得到节点的孩子

|下标|data|parent| firstchild|
-----------------------------
0   | A   |  -1  |    -1    |
-----------------------------
1   | B   |  0   |     3    |
----------------------------|
2   | C   |  0   |     4    |
-----------------------------
3   | D   |  1   |     -1   | 
-----------------------------
4   | E   |  2   |     -1   | 
-----------------------------

如此类推，我们可以增加 rightslib 来寻找它的右兄弟

## 孩子表示法
[data|child1|child2|....|childd]

child 用来指向它的孩子

但这种需要预留多少child位置呢？

在这里加多个 degree 来记录这里有多少个孩子

[data|degree|child1|child2|....|childd]

[A|2|child1|child2]

child1 指向 B，child2 指向 C

degree 表示节点的度

这种方法节省空间，但要维护节点的度数值，如果需要增加，在运算上带来时间上的损耗

另外一种表示方式为【单链表存储结构 + 顺序存储结构】

【简言而之】元素存储在顺序结构[data|firstchild]，firstchild 指向 [child下标|next] , next 指向下一个元素，通过链表减少[data|child1|child2|....|childd]结构计算压力

## 孩子兄弟表示法

同样道理，通过 添加 rightslib 不断指向右兄弟
[data|firstchild|rightslib]


# 总结

树的结构，能够通过层次，左右子树的方式，进行元素的分类，适应多个

